

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pickletools &mdash; Python Standard Library</title>
  

  
  
    <link rel="shortcut icon" href="../_static/py.png"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Python Standard Library" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Python Standard Library
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../01to10.html">Ch 01 - 10</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11to20.html">Ch 11 - 20</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21to30.html">Ch 21 - 30</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31to37.html">Ch 31 - 37</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_all.html">api</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Python Standard Library</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>pickletools</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pickletools</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;&quot;Executable documentation&quot; for the pickle module.</span>

<span class="sd">Extensive comments about the pickle protocols and pickle-machine opcodes</span>
<span class="sd">can be found here.  Some functions meant for external use:</span>

<span class="sd">genops(pickle)</span>
<span class="sd">   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.</span>

<span class="sd">dis(pickle, out=None, memo=None, indentlevel=4)</span>
<span class="sd">   Print a symbolic disassembly of a pickle.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dis&#39;</span><span class="p">,</span> <span class="s1">&#39;genops&#39;</span><span class="p">,</span> <span class="s1">&#39;optimize&#39;</span><span class="p">]</span>

<span class="c1"># Other ideas:</span>
<span class="c1">#</span>
<span class="c1"># - A pickle verifier:  read a pickle and check it exhaustively for</span>
<span class="c1">#   well-formedness.  dis() does a lot of this already.</span>
<span class="c1">#</span>
<span class="c1"># - A protocol identifier:  examine a pickle and return its protocol number</span>
<span class="c1">#   (== the highest .proto attr value among all the opcodes in the pickle).</span>
<span class="c1">#   dis() already prints this info at the end.</span>
<span class="c1">#</span>
<span class="c1"># - A pickle optimizer:  for example, tuple-building code is sometimes more</span>
<span class="c1">#   elaborate than necessary, catering for the possibility that the tuple</span>
<span class="c1">#   is recursive.  Or lots of times a PUT is generated that&#39;s never accessed</span>
<span class="c1">#   by a later GET.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&quot;A pickle&quot; is a program for a virtual pickle machine (PM, but more accurately</span>
<span class="sd">called an unpickling machine).  It&#39;s a sequence of opcodes, interpreted by the</span>
<span class="sd">PM, building an arbitrarily complex Python object.</span>

<span class="sd">For the most part, the PM is very simple:  there are no looping, testing, or</span>
<span class="sd">conditional instructions, no arithmetic and no function calls.  Opcodes are</span>
<span class="sd">executed once each, from first to last, until a STOP opcode is reached.</span>

<span class="sd">The PM has two data areas, &quot;the stack&quot; and &quot;the memo&quot;.</span>

<span class="sd">Many opcodes push Python objects onto the stack; e.g., INT pushes a Python</span>
<span class="sd">integer object on the stack, whose value is gotten from a decimal string</span>
<span class="sd">literal immediately following the INT opcode in the pickle bytestream.  Other</span>
<span class="sd">opcodes take Python objects off the stack.  The result of unpickling is</span>
<span class="sd">whatever object is left on the stack when the final STOP opcode is executed.</span>

<span class="sd">The memo is simply an array of objects, or it can be implemented as a dict</span>
<span class="sd">mapping little integers to objects.  The memo serves as the PM&#39;s &quot;long term</span>
<span class="sd">memory&quot;, and the little integers indexing the memo are akin to variable</span>
<span class="sd">names.  Some opcodes pop a stack object into the memo at a given index,</span>
<span class="sd">and others push a memo object at a given index onto the stack again.</span>

<span class="sd">At heart, that&#39;s all the PM has.  Subtleties arise for these reasons:</span>

<span class="sd">+ Object identity.  Objects can be arbitrarily complex, and subobjects</span>
<span class="sd">  may be shared (for example, the list [a, a] refers to the same object a</span>
<span class="sd">  twice).  It can be vital that unpickling recreate an isomorphic object</span>
<span class="sd">  graph, faithfully reproducing sharing.</span>

<span class="sd">+ Recursive objects.  For example, after &quot;L = []; L.append(L)&quot;, L is a</span>
<span class="sd">  list, and L[0] is the same list.  This is related to the object identity</span>
<span class="sd">  point, and some sequences of pickle opcodes are subtle in order to</span>
<span class="sd">  get the right result in all cases.</span>

<span class="sd">+ Things pickle doesn&#39;t know everything about.  Examples of things pickle</span>
<span class="sd">  does know everything about are Python&#39;s builtin scalar and container</span>
<span class="sd">  types, like ints and tuples.  They generally have opcodes dedicated to</span>
<span class="sd">  them.  For things like module references and instances of user-defined</span>
<span class="sd">  classes, pickle&#39;s knowledge is limited.  Historically, many enhancements</span>
<span class="sd">  have been made to the pickle protocol in order to do a better (faster,</span>
<span class="sd">  and/or more compact) job on those.</span>

<span class="sd">+ Backward compatibility and micro-optimization.  As explained below,</span>
<span class="sd">  pickle opcodes never go away, not even when better ways to do a thing</span>
<span class="sd">  get invented.  The repertoire of the PM just keeps growing over time.</span>
<span class="sd">  For example, protocol 0 had two opcodes for building Python integers (INT</span>
<span class="sd">  and LONG), protocol 1 added three more for more-efficient pickling of short</span>
<span class="sd">  integers, and protocol 2 added two more for more-efficient pickling of</span>
<span class="sd">  long integers (before protocol 2, the only ways to pickle a Python long</span>
<span class="sd">  took time quadratic in the number of digits, for both pickling and</span>
<span class="sd">  unpickling).  &quot;Opcode bloat&quot; isn&#39;t so much a subtlety as a source of</span>
<span class="sd">  wearying complication.</span>


<span class="sd">Pickle protocols:</span>

<span class="sd">For compatibility, the meaning of a pickle opcode never changes.  Instead new</span>
<span class="sd">pickle opcodes get added, and each version&#39;s unpickler can handle all the</span>
<span class="sd">pickle opcodes in all protocol versions to date.  So old pickles continue to</span>
<span class="sd">be readable forever.  The pickler can generally be told to restrict itself to</span>
<span class="sd">the subset of opcodes available under previous protocol versions too, so that</span>
<span class="sd">users can create pickles under the current version readable by older</span>
<span class="sd">versions.  However, a pickle does not contain its version number embedded</span>
<span class="sd">within it.  If an older unpickler tries to read a pickle using a later</span>
<span class="sd">protocol, the result is most likely an exception due to seeing an unknown (in</span>
<span class="sd">the older unpickler) opcode.</span>

<span class="sd">The original pickle used what&#39;s now called &quot;protocol 0&quot;, and what was called</span>
<span class="sd">&quot;text mode&quot; before Python 2.3.  The entire pickle bytestream is made up of</span>
<span class="sd">printable 7-bit ASCII characters, plus the newline character, in protocol 0.</span>
<span class="sd">That&#39;s why it was called text mode.  Protocol 0 is small and elegant, but</span>
<span class="sd">sometimes painfully inefficient.</span>

<span class="sd">The second major set of additions is now called &quot;protocol 1&quot;, and was called</span>
<span class="sd">&quot;binary mode&quot; before Python 2.3.  This added many opcodes with arguments</span>
<span class="sd">consisting of arbitrary bytes, including NUL bytes and unprintable &quot;high bit&quot;</span>
<span class="sd">bytes.  Binary mode pickles can be substantially smaller than equivalent</span>
<span class="sd">text mode pickles, and sometimes faster too; e.g., BININT represents a 4-byte</span>
<span class="sd">int as 4 bytes following the opcode, which is cheaper to unpickle than the</span>
<span class="sd">(perhaps) 11-character decimal string attached to INT.  Protocol 1 also added</span>
<span class="sd">a number of opcodes that operate on many stack elements at once (like APPENDS</span>
<span class="sd">and SETITEMS), and &quot;shortcut&quot; opcodes (like EMPTY_DICT and EMPTY_TUPLE).</span>

<span class="sd">The third major set of additions came in Python 2.3, and is called &quot;protocol</span>
<span class="sd">2&quot;.  This added:</span>

<span class="sd">- A better way to pickle instances of new-style classes (NEWOBJ).</span>

<span class="sd">- A way for a pickle to identify its protocol (PROTO).</span>

<span class="sd">- Time- and space- efficient pickling of long ints (LONG{1,4}).</span>

<span class="sd">- Shortcuts for small tuples (TUPLE{1,2,3}}.</span>

<span class="sd">- Dedicated opcodes for bools (NEWTRUE, NEWFALSE).</span>

<span class="sd">- The &quot;extension registry&quot;, a vector of popular objects that can be pushed</span>
<span class="sd">  efficiently by index (EXT{1,2,4}).  This is akin to the memo and GET, but</span>
<span class="sd">  the registry contents are predefined (there&#39;s nothing akin to the memo&#39;s</span>
<span class="sd">  PUT).</span>

<span class="sd">Another independent change with Python 2.3 is the abandonment of any</span>
<span class="sd">pretense that it might be safe to load pickles received from untrusted</span>
<span class="sd">parties -- no sufficient security analysis has been done to guarantee</span>
<span class="sd">this and there isn&#39;t a use case that warrants the expense of such an</span>
<span class="sd">analysis.</span>

<span class="sd">To this end, all tests for __safe_for_unpickling__ or for</span>
<span class="sd">copy_reg.safe_constructors are removed from the unpickling code.</span>
<span class="sd">References to these variables in the descriptions below are to be seen</span>
<span class="sd">as describing unpickling in Python 2.2 and before.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Meta-rule:  Descriptions are stored in instances of descriptor objects,</span>
<span class="c1"># with plain constructors.  No meta-language is defined from which</span>
<span class="c1"># descriptors could be constructed.  If you want, e.g., XML, write a little</span>
<span class="c1"># program to generate XML from the objects.</span>

<span class="c1">##############################################################################</span>
<span class="c1"># Some pickle opcodes have an argument, following the opcode in the</span>
<span class="c1"># bytestream.  An argument is of a specific type, described by an instance</span>
<span class="c1"># of ArgumentDescriptor.  These are not to be confused with arguments taken</span>
<span class="c1"># off the stack -- ArgumentDescriptor applies only to arguments embedded in</span>
<span class="c1"># the opcode stream, immediately following an opcode.</span>

<span class="c1"># Represents the number of bytes consumed by an argument delimited by the</span>
<span class="c1"># next newline character.</span>
<span class="n">UP_TO_NEWLINE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Represents the number of bytes consumed by a two-argument opcode where</span>
<span class="c1"># the first argument gives the number of bytes in the second argument.</span>
<span class="n">TAKEN_FROM_ARGUMENT1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>   <span class="c1"># num bytes is 1-byte unsigned int</span>
<span class="n">TAKEN_FROM_ARGUMENT4</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>   <span class="c1"># num bytes is 4-byte signed little-endian int</span>

<div class="viewcode-block" id="ArgumentDescriptor"><a class="viewcode-back" href="../generated/generated/pickletools.ArgumentDescriptor.html#pickletools.ArgumentDescriptor">[docs]</a><span class="k">class</span> <span class="nc">ArgumentDescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="c1"># name of descriptor record, also a module global name; a string</span>
        <span class="s1">&#39;name&#39;</span><span class="p">,</span>

        <span class="c1"># length of argument, in bytes; an int; UP_TO_NEWLINE and</span>
        <span class="c1"># TAKEN_FROM_ARGUMENT{1,4} are negative values for variable-length</span>
        <span class="c1"># cases</span>
        <span class="s1">&#39;n&#39;</span><span class="p">,</span>

        <span class="c1"># a function taking a file-like object, reading this kind of argument</span>
        <span class="c1"># from the object at the current position, advancing the current</span>
        <span class="c1"># position by n bytes, and returning the value of the argument</span>
        <span class="s1">&#39;reader&#39;</span><span class="p">,</span>

        <span class="c1"># human-readable docs for this arg descriptor; a string</span>
        <span class="s1">&#39;doc&#39;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="ArgumentDescriptor.__init__"><a class="viewcode-back" href="../generated/generated/pickletools.ArgumentDescriptor.__init__.html#pickletools.ArgumentDescriptor.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span>
                                       <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                                             <span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
                                             <span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">reader</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span></div></div>

<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">unpack</span> <span class="k">as</span> <span class="n">_unpack</span>

<div class="viewcode-block" id="read_uint1"><a class="viewcode-back" href="../generated/pickletools.read_uint1.html#pickletools.read_uint1">[docs]</a><span class="k">def</span> <span class="nf">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_uint1(StringIO.StringIO(&#39;\xff&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough data in stream to read uint1&quot;</span><span class="p">)</span></div>

<span class="n">uint1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;uint1&#39;</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">reader</span><span class="o">=</span><span class="n">read_uint1</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;One-byte unsigned integer.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_uint2"><a class="viewcode-back" href="../generated/pickletools.read_uint2.html#pickletools.read_uint2">[docs]</a><span class="k">def</span> <span class="nf">read_uint2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_uint2(StringIO.StringIO(&#39;\xff\x00&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_uint2(StringIO.StringIO(&#39;\xff\xff&#39;))</span>
<span class="sd">    65535</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s2">&quot;&lt;H&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough data in stream to read uint2&quot;</span><span class="p">)</span></div>

<span class="n">uint2</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;uint2&#39;</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">reader</span><span class="o">=</span><span class="n">read_uint2</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Two-byte unsigned integer, little-endian.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_int4"><a class="viewcode-back" href="../generated/pickletools.read_int4.html#pickletools.read_int4">[docs]</a><span class="k">def</span> <span class="nf">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_int4(StringIO.StringIO(&#39;\xff\x00\x00\x00&#39;))</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; read_int4(StringIO.StringIO(&#39;\x00\x00\x00\x80&#39;)) == -(2**31)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s2">&quot;&lt;i&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough data in stream to read int4&quot;</span><span class="p">)</span></div>

<span class="n">int4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
           <span class="n">name</span><span class="o">=</span><span class="s1">&#39;int4&#39;</span><span class="p">,</span>
           <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
           <span class="n">reader</span><span class="o">=</span><span class="n">read_int4</span><span class="p">,</span>
           <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Four-byte signed integer, little-endian, 2&#39;s complement.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_stringnl"><a class="viewcode-back" href="../generated/pickletools.read_stringnl.html#pickletools.read_stringnl">[docs]</a><span class="k">def</span> <span class="nf">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;&#39;abcd&#39;\nefg\n&quot;))</span>
<span class="sd">    &#39;abcd&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;\n&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: no string quotes around &#39;&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;\n&quot;), stripquotes=False)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;&#39;&#39;\n&quot;))</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    &gt;&gt;&gt; read_stringnl(StringIO.StringIO(&#39;&quot;abcd&quot;&#39;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: no newline found when trying to read stringnl</span>

<span class="sd">    Embedded escapes are undone in the result.</span>
<span class="sd">    &gt;&gt;&gt; read_stringnl(StringIO.StringIO(r&quot;&#39;a\n\\b\x00c\td&#39;&quot; + &quot;\n&#39;e&#39;&quot;))</span>
<span class="sd">    &#39;a\n\\b\x00c\td&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no newline found when trying to read stringnl&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># lose the newline</span>

    <span class="k">if</span> <span class="n">stripquotes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="s2">&quot;&#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;strinq quote </span><span class="si">%r</span><span class="s2"> not found at both &quot;</span>
                                     <span class="s2">&quot;ends of </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no string quotes around </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># I&#39;m not sure when &#39;string_escape&#39; was added to the std codecs; it&#39;s</span>
    <span class="c1"># crazy not to use it if it&#39;s there.</span>
    <span class="k">if</span> <span class="n">decode</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;string_escape&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>

<span class="n">stringnl</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;stringnl&#39;</span><span class="p">,</span>
               <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
               <span class="n">reader</span><span class="o">=</span><span class="n">read_stringnl</span><span class="p">,</span>
               <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A newline-terminated string.</span>

<span class="s2">                   This is a repr-style string, with embedded escapes, and</span>
<span class="s2">                   bracketing quotes.</span>
<span class="s2">                   &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="read_stringnl_noescape"><a class="viewcode-back" href="../generated/pickletools.read_stringnl_noescape.html#pickletools.read_stringnl_noescape">[docs]</a><span class="k">def</span> <span class="nf">read_stringnl_noescape</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span></div>

<span class="n">stringnl_noescape</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;stringnl_noescape&#39;</span><span class="p">,</span>
                        <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                        <span class="n">reader</span><span class="o">=</span><span class="n">read_stringnl_noescape</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A newline-terminated string.</span>

<span class="s2">                        This is a str-style string, without embedded escapes,</span>
<span class="s2">                        or bracketing quotes.  It should consist solely of</span>
<span class="s2">                        printable ASCII characters.</span>
<span class="s2">                        &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="read_stringnl_noescape_pair"><a class="viewcode-back" href="../generated/pickletools.read_stringnl_noescape_pair.html#pickletools.read_stringnl_noescape_pair">[docs]</a><span class="k">def</span> <span class="nf">read_stringnl_noescape_pair</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_stringnl_noescape_pair(StringIO.StringIO(&quot;Queue\nEmpty\njunk&quot;))</span>
<span class="sd">    &#39;Queue Empty&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">read_stringnl_noescape</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">read_stringnl_noescape</span><span class="p">(</span><span class="n">f</span><span class="p">))</span></div>

<span class="n">stringnl_noescape_pair</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;stringnl_noescape_pair&#39;</span><span class="p">,</span>
                             <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                             <span class="n">reader</span><span class="o">=</span><span class="n">read_stringnl_noescape_pair</span><span class="p">,</span>
                             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A pair of newline-terminated strings.</span>

<span class="s2">                             These are str-style strings, without embedded</span>
<span class="s2">                             escapes, or bracketing quotes.  They should</span>
<span class="s2">                             consist solely of printable ASCII characters.</span>
<span class="s2">                             The pair is returned as a single string, with</span>
<span class="s2">                             a single blank separating the two strings.</span>
<span class="s2">                             &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="read_string4"><a class="viewcode-back" href="../generated/pickletools.read_string4.html#pickletools.read_string4">[docs]</a><span class="k">def</span> <span class="nf">read_string4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_string4(StringIO.StringIO(&quot;\x00\x00\x00\x00abc&quot;))</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_string4(StringIO.StringIO(&quot;\x03\x00\x00\x00abcdef&quot;))</span>
<span class="sd">    &#39;abc&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_string4(StringIO.StringIO(&quot;\x00\x00\x00\x03abcdef&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 50331648 bytes in a string4, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;string4 byte count &lt; 0: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected </span><span class="si">%d</span><span class="s2"> bytes in a string4, but only </span><span class="si">%d</span><span class="s2"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span></div>

<span class="n">string4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;string4&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_string4</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A counted string.</span>

<span class="s2">              The first argument is a 4-byte little-endian signed int giving</span>
<span class="s2">              the number of bytes in the string, and the second argument is</span>
<span class="s2">              that many bytes.</span>
<span class="s2">              &quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_string1"><a class="viewcode-back" href="../generated/pickletools.read_string1.html#pickletools.read_string1">[docs]</a><span class="k">def</span> <span class="nf">read_string1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_string1(StringIO.StringIO(&quot;\x00&quot;))</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_string1(StringIO.StringIO(&quot;\x03abcdef&quot;))</span>
<span class="sd">    &#39;abc&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected </span><span class="si">%d</span><span class="s2"> bytes in a string1, but only </span><span class="si">%d</span><span class="s2"> remain&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span></div>

<span class="n">string1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;string1&quot;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_string1</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A counted string.</span>

<span class="s2">              The first argument is a 1-byte unsigned int giving the number</span>
<span class="s2">              of bytes in the string, and the second argument is that many</span>
<span class="s2">              bytes.</span>
<span class="s2">              &quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_unicodestringnl"><a class="viewcode-back" href="../generated/pickletools.read_unicodestringnl.html#pickletools.read_unicodestringnl">[docs]</a><span class="k">def</span> <span class="nf">read_unicodestringnl</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_unicodestringnl(StringIO.StringIO(&quot;abc\uabcd\njunk&quot;))</span>
<span class="sd">    u&#39;abc\uabcd&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no newline found when trying to read &quot;</span>
                         <span class="s2">&quot;unicodestringnl&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># lose the newline</span>
    <span class="k">return</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;raw-unicode-escape&#39;</span><span class="p">)</span></div>

<span class="n">unicodestringnl</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                      <span class="n">name</span><span class="o">=</span><span class="s1">&#39;unicodestringnl&#39;</span><span class="p">,</span>
                      <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                      <span class="n">reader</span><span class="o">=</span><span class="n">read_unicodestringnl</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A newline-terminated Unicode string.</span>

<span class="s2">                      This is raw-unicode-escape encoded, so consists of</span>
<span class="s2">                      printable ASCII characters, and may contain embedded</span>
<span class="s2">                      escape sequences.</span>
<span class="s2">                      &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="read_unicodestring4"><a class="viewcode-back" href="../generated/pickletools.read_unicodestring4.html#pickletools.read_unicodestring4">[docs]</a><span class="k">def</span> <span class="nf">read_unicodestring4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; s = u&#39;abcd\uabcd&#39;</span>
<span class="sd">    &gt;&gt;&gt; enc = s.encode(&#39;utf-8&#39;)</span>
<span class="sd">    &gt;&gt;&gt; enc</span>
<span class="sd">    &#39;abcd\xea\xaf\x8d&#39;</span>
<span class="sd">    &gt;&gt;&gt; n = chr(len(enc)) + chr(0) * 3  # little-endian 4-byte length</span>
<span class="sd">    &gt;&gt;&gt; t = read_unicodestring4(StringIO.StringIO(n + enc + &#39;junk&#39;))</span>
<span class="sd">    &gt;&gt;&gt; s == t</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; read_unicodestring4(StringIO.StringIO(n + enc[:-1]))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: expected 7 bytes in a unicodestring4, but only 6 remain</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unicodestring4 byte count &lt; 0: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected </span><span class="si">%d</span><span class="s2"> bytes in a unicodestring4, but only </span><span class="si">%d</span><span class="s2"> &quot;</span>
                     <span class="s2">&quot;remain&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span></div>

<span class="n">unicodestring4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;unicodestring4&quot;</span><span class="p">,</span>
                    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">,</span>
                    <span class="n">reader</span><span class="o">=</span><span class="n">read_unicodestring4</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A counted Unicode string.</span>

<span class="s2">                    The first argument is a 4-byte little-endian signed int</span>
<span class="s2">                    giving the number of bytes in the string, and the second</span>
<span class="s2">                    argument-- the UTF-8 encoding of the Unicode string --</span>
<span class="s2">                    contains that many bytes.</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_decimalnl_short"><a class="viewcode-back" href="../generated/pickletools.read_decimalnl_short.html#pickletools.read_decimalnl_short">[docs]</a><span class="k">def</span> <span class="nf">read_decimalnl_short</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_decimalnl_short(StringIO.StringIO(&quot;1234\n56&quot;))</span>
<span class="sd">    1234</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_short(StringIO.StringIO(&quot;1234L\n56&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: trailing &#39;L&#39; not allowed in &#39;1234L&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing &#39;L&#39; not allowed in </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># It&#39;s not necessarily true that the result fits in a Python short int:</span>
    <span class="c1"># the pickle may have been written on a 64-bit box.  There&#39;s also a hack</span>
    <span class="c1"># for True and False here.</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;00&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">long</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="read_decimalnl_long"><a class="viewcode-back" href="../generated/pickletools.read_decimalnl_long.html#pickletools.read_decimalnl_long">[docs]</a><span class="k">def</span> <span class="nf">read_decimalnl_long</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_long(StringIO.StringIO(&quot;1234\n56&quot;))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: trailing &#39;L&#39; required in &#39;1234&#39;</span>

<span class="sd">    Someday the trailing &#39;L&#39; will probably go away from this output.</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_long(StringIO.StringIO(&quot;1234L\n56&quot;))</span>
<span class="sd">    1234L</span>

<span class="sd">    &gt;&gt;&gt; read_decimalnl_long(StringIO.StringIO(&quot;123456789012345678901234L\n6&quot;))</span>
<span class="sd">    123456789012345678901234L</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing &#39;L&#39; required in </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">long</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<span class="n">decimalnl_short</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                      <span class="n">name</span><span class="o">=</span><span class="s1">&#39;decimalnl_short&#39;</span><span class="p">,</span>
                      <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                      <span class="n">reader</span><span class="o">=</span><span class="n">read_decimalnl_short</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A newline-terminated decimal integer literal.</span>

<span class="s2">                          This never has a trailing &#39;L&#39;, and the integer fit</span>
<span class="s2">                          in a short Python int on the box where the pickle</span>
<span class="s2">                          was written -- but there&#39;s no guarantee it will fit</span>
<span class="s2">                          in a short Python int on the box where the pickle</span>
<span class="s2">                          is read.</span>
<span class="s2">                          &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">decimalnl_long</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                     <span class="n">name</span><span class="o">=</span><span class="s1">&#39;decimalnl_long&#39;</span><span class="p">,</span>
                     <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                     <span class="n">reader</span><span class="o">=</span><span class="n">read_decimalnl_long</span><span class="p">,</span>
                     <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A newline-terminated decimal integer literal.</span>

<span class="s2">                         This has a trailing &#39;L&#39;, and can represent integers</span>
<span class="s2">                         of any size.</span>
<span class="s2">                         &quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read_floatnl"><a class="viewcode-back" href="../generated/pickletools.read_floatnl.html#pickletools.read_floatnl">[docs]</a><span class="k">def</span> <span class="nf">read_floatnl</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_floatnl(StringIO.StringIO(&quot;-1.25\n6&quot;))</span>
<span class="sd">    -1.25</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<span class="n">floatnl</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s1">&#39;floatnl&#39;</span><span class="p">,</span>
              <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
              <span class="n">reader</span><span class="o">=</span><span class="n">read_floatnl</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A newline-terminated decimal floating literal.</span>

<span class="s2">              In general this requires 17 significant digits for roundtrip</span>
<span class="s2">              identity, and pickling then unpickling infinities, NaNs, and</span>
<span class="s2">              minus zero doesn&#39;t work across boxes, or on some boxes even</span>
<span class="s2">              on itself (e.g., Windows can&#39;t read the strings it produces</span>
<span class="s2">              for infinities or NaNs).</span>
<span class="s2">              &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="read_float8"><a class="viewcode-back" href="../generated/pickletools.read_float8.html#pickletools.read_float8">[docs]</a><span class="k">def</span> <span class="nf">read_float8</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO, struct</span>
<span class="sd">    &gt;&gt;&gt; raw = struct.pack(&quot;&gt;d&quot;, -1.25)</span>
<span class="sd">    &gt;&gt;&gt; raw</span>
<span class="sd">    &#39;\xbf\xf4\x00\x00\x00\x00\x00\x00&#39;</span>
<span class="sd">    &gt;&gt;&gt; read_float8(StringIO.StringIO(raw + &quot;\n&quot;))</span>
<span class="sd">    -1.25</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpack</span><span class="p">(</span><span class="s2">&quot;&gt;d&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough data in stream to read float8&quot;</span><span class="p">)</span></div>


<span class="n">float8</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;float8&#39;</span><span class="p">,</span>
             <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
             <span class="n">reader</span><span class="o">=</span><span class="n">read_float8</span><span class="p">,</span>
             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;An 8-byte binary representation of a float, big-endian.</span>

<span class="s2">             The format is unique to Python, and shared with the struct</span>
<span class="s2">             module (format string &#39;&gt;d&#39;) &quot;in theory&quot; (the struct and cPickle</span>
<span class="s2">             implementations don&#39;t share the code -- they should).  It&#39;s</span>
<span class="s2">             strongly related to the IEEE-754 double format, and, in normal</span>
<span class="s2">             cases, is in fact identical to the big-endian 754 double format.</span>
<span class="s2">             On other boxes the dynamic range is limited to that of a 754</span>
<span class="s2">             double, and &quot;add a half and chop&quot; rounding is used to reduce</span>
<span class="s2">             the precision to 53 bits.  However, even on a 754 box,</span>
<span class="s2">             infinities, NaNs, and minus zero may not be handled correctly</span>
<span class="s2">             (may not survive roundtrip pickling intact).</span>
<span class="s2">             &quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Protocol 2 formats</span>

<span class="kn">from</span> <span class="nn">pickle</span> <span class="kn">import</span> <span class="n">decode_long</span>

<div class="viewcode-block" id="read_long1"><a class="viewcode-back" href="../generated/pickletools.read_long1.html#pickletools.read_long1">[docs]</a><span class="k">def</span> <span class="nf">read_long1</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_long1(StringIO.StringIO(&quot;\x00&quot;))</span>
<span class="sd">    0L</span>
<span class="sd">    &gt;&gt;&gt; read_long1(StringIO.StringIO(&quot;\x02\xff\x00&quot;))</span>
<span class="sd">    255L</span>
<span class="sd">    &gt;&gt;&gt; read_long1(StringIO.StringIO(&quot;\x02\xff\x7f&quot;))</span>
<span class="sd">    32767L</span>
<span class="sd">    &gt;&gt;&gt; read_long1(StringIO.StringIO(&quot;\x02\x00\xff&quot;))</span>
<span class="sd">    -256L</span>
<span class="sd">    &gt;&gt;&gt; read_long1(StringIO.StringIO(&quot;\x02\x00\x80&quot;))</span>
<span class="sd">    -32768L</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_uint1</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough data in stream to read long1&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decode_long</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<span class="n">long1</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;long1&quot;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT1</span><span class="p">,</span>
    <span class="n">reader</span><span class="o">=</span><span class="n">read_long1</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A binary long, little-endian, using 1-byte size.</span>

<span class="s2">    This first reads one byte as an unsigned size, then reads that</span>
<span class="s2">    many bytes and interprets them as a little-endian 2&#39;s-complement long.</span>
<span class="s2">    If the size is 0, that&#39;s taken as a shortcut for the long 0L.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="read_long4"><a class="viewcode-back" href="../generated/pickletools.read_long4.html#pickletools.read_long4">[docs]</a><span class="k">def</span> <span class="nf">read_long4</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; import StringIO</span>
<span class="sd">    &gt;&gt;&gt; read_long4(StringIO.StringIO(&quot;\x02\x00\x00\x00\xff\x00&quot;))</span>
<span class="sd">    255L</span>
<span class="sd">    &gt;&gt;&gt; read_long4(StringIO.StringIO(&quot;\x02\x00\x00\x00\xff\x7f&quot;))</span>
<span class="sd">    32767L</span>
<span class="sd">    &gt;&gt;&gt; read_long4(StringIO.StringIO(&quot;\x02\x00\x00\x00\x00\xff&quot;))</span>
<span class="sd">    -256L</span>
<span class="sd">    &gt;&gt;&gt; read_long4(StringIO.StringIO(&quot;\x02\x00\x00\x00\x00\x80&quot;))</span>
<span class="sd">    -32768L</span>
<span class="sd">    &gt;&gt;&gt; read_long1(StringIO.StringIO(&quot;\x00\x00\x00\x00&quot;))</span>
<span class="sd">    0L</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read_int4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;long4 byte count &lt; 0: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough data in stream to read long4&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decode_long</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<span class="n">long4</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;long4&quot;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="n">TAKEN_FROM_ARGUMENT4</span><span class="p">,</span>
    <span class="n">reader</span><span class="o">=</span><span class="n">read_long4</span><span class="p">,</span>
    <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A binary representation of a long, little-endian.</span>

<span class="s2">    This first reads four bytes as a signed size (but requires the</span>
<span class="s2">    size to be &gt;= 0), then reads that many bytes and interprets them</span>
<span class="s2">    as a little-endian 2&#39;s-complement long.  If the size is 0, that&#39;s taken</span>
<span class="s2">    as a shortcut for the long 0L, although LONG1 should really be used</span>
<span class="s2">    then instead (and in any case where # of bytes &lt; 256).</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>


<span class="c1">##############################################################################</span>
<span class="c1"># Object descriptors.  The stack used by the pickle machine holds objects,</span>
<span class="c1"># and in the stack_before and stack_after attributes of OpcodeInfo</span>
<span class="c1"># descriptors we need names to describe the various types of objects that can</span>
<span class="c1"># appear on the stack.</span>

<div class="viewcode-block" id="StackObject"><a class="viewcode-back" href="../generated/generated/pickletools.StackObject.html#pickletools.StackObject">[docs]</a><span class="k">class</span> <span class="nc">StackObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="c1"># name of descriptor record, for info only</span>
        <span class="s1">&#39;name&#39;</span><span class="p">,</span>

        <span class="c1"># type of object, or tuple of type objects (meaning the object can</span>
        <span class="c1"># be of any type in the tuple)</span>
        <span class="s1">&#39;obtype&#39;</span><span class="p">,</span>

        <span class="c1"># human-readable docs for this kind of stack object; a string</span>
        <span class="s1">&#39;doc&#39;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="StackObject.__init__"><a class="viewcode-back" href="../generated/generated/pickletools.StackObject.__init__.html#pickletools.StackObject.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obtype</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">contained</span> <span class="ow">in</span> <span class="n">obtype</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">contained</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obtype</span> <span class="o">=</span> <span class="n">obtype</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span></div>

<div class="viewcode-block" id="StackObject.__repr__"><a class="viewcode-back" href="../generated/generated/pickletools.StackObject.__repr__.html#pickletools.StackObject.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div></div>


<span class="n">pyint</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
            <span class="n">obtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A short (as opposed to long) Python integer object.&quot;</span><span class="p">)</span>

<span class="n">pylong</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;long&#39;</span><span class="p">,</span>
             <span class="n">obtype</span><span class="o">=</span><span class="nb">long</span><span class="p">,</span>
             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A long (as opposed to short) Python integer object.&quot;</span><span class="p">)</span>

<span class="n">pyinteger_or_bool</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;int_or_bool&#39;</span><span class="p">,</span>
                        <span class="n">obtype</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python integer object (short or long), or &quot;</span>
                            <span class="s2">&quot;a Python bool.&quot;</span><span class="p">)</span>

<span class="n">pybool</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span>
             <span class="n">obtype</span><span class="o">=</span><span class="p">(</span><span class="nb">bool</span><span class="p">,),</span>
             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python bool object.&quot;</span><span class="p">)</span>

<span class="n">pyfloat</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span>
              <span class="n">obtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python float object.&quot;</span><span class="p">)</span>

<span class="n">pystring</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="p">,</span>
               <span class="n">obtype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
               <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python string object.&quot;</span><span class="p">)</span>

<span class="n">pyunicode</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">,</span>
                <span class="n">obtype</span><span class="o">=</span><span class="nb">unicode</span><span class="p">,</span>
                <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python Unicode string object.&quot;</span><span class="p">)</span>

<span class="n">pynone</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span>
             <span class="n">obtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span>
             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The Python None object.&quot;</span><span class="p">)</span>

<span class="n">pytuple</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
              <span class="n">name</span><span class="o">=</span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span>
              <span class="n">obtype</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python tuple object.&quot;</span><span class="p">)</span>

<span class="n">pylist</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">,</span>
             <span class="n">obtype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python list object.&quot;</span><span class="p">)</span>

<span class="n">pydict</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
             <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">,</span>
             <span class="n">obtype</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span>
             <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A Python dict object.&quot;</span><span class="p">)</span>

<span class="n">anyobject</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span>
                <span class="n">obtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
                <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Any kind of object whatsoever.&quot;</span><span class="p">)</span>

<span class="n">markobject</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
                 <span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span>
                 <span class="n">obtype</span><span class="o">=</span><span class="n">StackObject</span><span class="p">,</span>
                 <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;&#39;The mark&#39; is a unique object.</span>

<span class="s2">                 Opcodes that operate on a variable number of objects</span>
<span class="s2">                 generally don&#39;t embed the count of objects in the opcode,</span>
<span class="s2">                 or pull it off the stack.  Instead the MARK opcode is used</span>
<span class="s2">                 to push a special marker object on the stack, and then</span>
<span class="s2">                 some other opcodes grab all the objects from the top of</span>
<span class="s2">                 the stack down to (but not including) the topmost marker</span>
<span class="s2">                 object.</span>
<span class="s2">                 &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">stackslice</span> <span class="o">=</span> <span class="n">StackObject</span><span class="p">(</span>
                 <span class="n">name</span><span class="o">=</span><span class="s2">&quot;stackslice&quot;</span><span class="p">,</span>
                 <span class="n">obtype</span><span class="o">=</span><span class="n">StackObject</span><span class="p">,</span>
                 <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;An object representing a contiguous slice of the stack.</span>

<span class="s2">                 This is used in conjunction with markobject, to represent all</span>
<span class="s2">                 of the stack following the topmost markobject.  For example,</span>
<span class="s2">                 the POP_MARK opcode changes the stack from</span>

<span class="s2">                     [..., markobject, stackslice]</span>
<span class="s2">                 to</span>
<span class="s2">                     [...]</span>

<span class="s2">                 No matter how many object are on the stack after the topmost</span>
<span class="s2">                 markobject, POP_MARK gets rid of all of them (including the</span>
<span class="s2">                 topmost markobject too).</span>
<span class="s2">                 &quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1">##############################################################################</span>
<span class="c1"># Descriptors for pickle opcodes.</span>

<div class="viewcode-block" id="OpcodeInfo"><a class="viewcode-back" href="../generated/generated/pickletools.OpcodeInfo.html#pickletools.OpcodeInfo">[docs]</a><span class="k">class</span> <span class="nc">OpcodeInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="c1"># symbolic name of opcode; a string</span>
        <span class="s1">&#39;name&#39;</span><span class="p">,</span>

        <span class="c1"># the code used in a bytestream to represent the opcode; a</span>
        <span class="c1"># one-character string</span>
        <span class="s1">&#39;code&#39;</span><span class="p">,</span>

        <span class="c1"># If the opcode has an argument embedded in the byte string, an</span>
        <span class="c1"># instance of ArgumentDescriptor specifying its type.  Note that</span>
        <span class="c1"># arg.reader(s) can be used to read and decode the argument from</span>
        <span class="c1"># the bytestream s, and arg.doc documents the format of the raw</span>
        <span class="c1"># argument bytes.  If the opcode doesn&#39;t have an argument embedded</span>
        <span class="c1"># in the bytestream, arg should be None.</span>
        <span class="s1">&#39;arg&#39;</span><span class="p">,</span>

        <span class="c1"># what the stack looks like before this opcode runs; a list</span>
        <span class="s1">&#39;stack_before&#39;</span><span class="p">,</span>

        <span class="c1"># what the stack looks like after this opcode runs; a list</span>
        <span class="s1">&#39;stack_after&#39;</span><span class="p">,</span>

        <span class="c1"># the protocol number in which this opcode was introduced; an int</span>
        <span class="s1">&#39;proto&#39;</span><span class="p">,</span>

        <span class="c1"># human-readable docs for this opcode; a string</span>
        <span class="s1">&#39;doc&#39;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="OpcodeInfo.__init__"><a class="viewcode-back" href="../generated/generated/pickletools.OpcodeInfo.__init__.html#pickletools.OpcodeInfo.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
                 <span class="n">stack_before</span><span class="p">,</span> <span class="n">stack_after</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span>

        <span class="k">assert</span> <span class="n">arg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ArgumentDescriptor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_before</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack_before</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">StackObject</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_before</span> <span class="o">=</span> <span class="n">stack_before</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_after</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack_after</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">StackObject</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_after</span> <span class="o">=</span> <span class="n">stack_after</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">proto</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proto</span> <span class="o">=</span> <span class="n">proto</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span></div></div>

<span class="n">I</span> <span class="o">=</span> <span class="n">OpcodeInfo</span>
<span class="n">opcodes</span> <span class="o">=</span> <span class="p">[</span>

    <span class="c1"># Ways to spell integers.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;INT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;I&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_short</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyinteger_or_bool</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push an integer or bool.</span>

<span class="s2">      The argument is a newline-terminated decimal literal string.</span>

<span class="s2">      The intent may have been that this always fit in a short Python int,</span>
<span class="s2">      but INT can be generated in pickles written on a 64-bit box that</span>
<span class="s2">      require a Python long on a 32-bit box.  The difference between this</span>
<span class="s2">      and LONG then is that INT skips a trailing &#39;L&#39;, and produces a short</span>
<span class="s2">      int whenever possible.</span>

<span class="s2">      Another difference is due to that, when bool was introduced as a</span>
<span class="s2">      distinct type in 2.3, builtin names True and False were also added to</span>
<span class="s2">      2.2.2, mapping to ints 1 and 0.  For compatibility in both directions,</span>
<span class="s2">      True gets pickled as INT + &quot;I01</span><span class="se">\\</span><span class="s2">n&quot;, and False as INT + &quot;I00</span><span class="se">\\</span><span class="s2">n&quot;.</span>
<span class="s2">      Leading zeroes are never produced for a genuine integer.  The 2.3</span>
<span class="s2">      (and later) unpicklers special-case these and return bool instead;</span>
<span class="s2">      earlier unpicklers ignore the leading &quot;0&quot; and return the int.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BININT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;J&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">int4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a four-byte signed integer.</span>

<span class="s2">      This handles the full range of Python (short) integers on a 32-bit</span>
<span class="s2">      box, directly as binary bytes (1 for the opcode and 4 for the integer).</span>
<span class="s2">      If the integer is non-negative and fits in 1 or 2 bytes, pickling via</span>
<span class="s2">      BININT1 or BININT2 saves space.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BININT1&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a one-byte unsigned integer.</span>

<span class="s2">      This is a space optimization for pickling very small non-negative ints,</span>
<span class="s2">      in range(256).</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BININT2&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint2</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyint</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a two-byte unsigned integer.</span>

<span class="s2">      This is a space optimization for pickling small positive ints, in</span>
<span class="s2">      range(256, 2**16).  Integers in range(256) can also be pickled via</span>
<span class="s2">      BININT2, but BININT1 instead saves a byte.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;LONG&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_long</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylong</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a long integer.</span>

<span class="s2">      The same as INT, except that the literal ends with &#39;L&#39;, and always</span>
<span class="s2">      unpickles to a Python long.  There doesn&#39;t seem a real purpose to the</span>
<span class="s2">      trailing &#39;L&#39;.</span>

<span class="s2">      Note that LONG takes time quadratic in the number of digits when</span>
<span class="s2">      unpickling (this is simply due to the nature of decimal-&gt;binary</span>
<span class="s2">      conversion).  Proto 2 added linear-time (in C; still quadratic-time</span>
<span class="s2">      in Python) LONG1 and LONG4 opcodes.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;LONG1&quot;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x8a</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">long1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylong</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Long integer using one-byte length.</span>

<span class="s2">      A more efficient encoding of a Python long; the long1 encoding</span>
<span class="s2">      says it all.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;LONG4&quot;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x8b</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">long4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylong</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Long integer using found-byte length.</span>

<span class="s2">      A more efficient encoding of a Python long; the long4 encoding</span>
<span class="s2">      says it all.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to spell strings (8-bit, not Unicode).</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;STRING&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pystring</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a Python string object.</span>

<span class="s2">      The argument is a repr-style string, with bracketing quote characters,</span>
<span class="s2">      and perhaps embedded escapes.  The argument extends until the next</span>
<span class="s2">      newline character.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINSTRING&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">string4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pystring</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a Python string object.</span>

<span class="s2">      There are two arguments:  the first is a 4-byte little-endian signed int</span>
<span class="s2">      giving the number of bytes in the string, and the second is that many</span>
<span class="s2">      bytes, which are taken literally as the string content.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;SHORT_BINSTRING&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">string1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pystring</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a Python string object.</span>

<span class="s2">      There are two arguments:  the first is a 1-byte unsigned int giving</span>
<span class="s2">      the number of bytes in the string, and the second is that many bytes,</span>
<span class="s2">      which are taken literally as the string content.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to spell None.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;NONE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pynone</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Push None on the stack.&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to spell bools, starting with proto 2.  See INT for how this was</span>
    <span class="c1"># done before proto 2.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;NEWTRUE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x88</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybool</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;True.</span>

<span class="s2">      Push True onto the stack.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;NEWFALSE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x89</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pybool</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;True.</span>

<span class="s2">      Push False onto the stack.&quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to spell Unicode strings.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;UNICODE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">unicodestringnl</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># this may be pure-text, but it&#39;s a later addition</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a Python Unicode string object.</span>

<span class="s2">      The argument is a raw-unicode-escape encoding of a Unicode string,</span>
<span class="s2">      and so may contain embedded escape sequences.  The argument extends</span>
<span class="s2">      until the next newline character.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINUNICODE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">unicodestring4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyunicode</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a Python Unicode string object.</span>

<span class="s2">      There are two arguments:  the first is a 4-byte little-endian signed int</span>
<span class="s2">      giving the number of bytes in the string.  The second is that many</span>
<span class="s2">      bytes, and is the UTF-8 encoding of the Unicode string.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to spell floats.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLOAT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">floatnl</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyfloat</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Newline-terminated decimal float literal.</span>

<span class="s2">      The argument is repr(a_float), and in general requires 17 significant</span>
<span class="s2">      digits for roundtrip conversion to be an identity (this is so for</span>
<span class="s2">      IEEE-754 double precision values, which is what Python float maps to</span>
<span class="s2">      on most boxes).</span>

<span class="s2">      In general, FLOAT cannot be used to transport infinities, NaNs, or</span>
<span class="s2">      minus zero across boxes (or even on a single box, if the platform C</span>
<span class="s2">      library can&#39;t read the strings it produces for such things -- Windows</span>
<span class="s2">      is like that), but may do less damage than BINFLOAT on boxes with</span>
<span class="s2">      greater precision or dynamic range than IEEE-754 double.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINFLOAT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">float8</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pyfloat</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Float stored in binary form, with 8 bytes of data.</span>

<span class="s2">      This generally requires less than half the space of FLOAT encoding.</span>
<span class="s2">      In general, BINFLOAT cannot be used to transport infinities, NaNs, or</span>
<span class="s2">      minus zero, raises an exception if the exponent exceeds the range of</span>
<span class="s2">      an IEEE-754 double, and retains no more than 53 bits of precision (if</span>
<span class="s2">      there are more than that, &quot;add a half and chop&quot; rounding is used to</span>
<span class="s2">      cut it back to 53 significant bits).</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to build lists.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EMPTY_LIST&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;]&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Push an empty list.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;APPEND&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Append an object to a list.</span>

<span class="s2">      Stack before:  ... pylist anyobject</span>
<span class="s2">      Stack after:   ... pylist+[anyobject]</span>

<span class="s2">      although pylist is really extended in-place.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;APPENDS&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">,</span> <span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Extend a list by a slice of stack objects.</span>

<span class="s2">      Stack before:  ... pylist markobject stackslice</span>
<span class="s2">      Stack after:   ... pylist+stackslice</span>

<span class="s2">      although pylist is really extended in-place.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;LIST&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;l&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylist</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a list out of the topmost stack slice, after markobject.</span>

<span class="s2">      All the stack entries following the topmost markobject are placed into</span>
<span class="s2">      a single Python list, which single list object replaces all of the</span>
<span class="s2">      stack from the topmost markobject onward.  For example,</span>

<span class="s2">      Stack before: ... markobject 1 2 3 &#39;abc&#39;</span>
<span class="s2">      Stack after:  ... [1, 2, 3, &#39;abc&#39;]</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to build tuples.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EMPTY_TUPLE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;)&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Push an empty tuple.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TUPLE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a tuple out of the topmost stack slice, after markobject.</span>

<span class="s2">      All the stack entries following the topmost markobject are placed into</span>
<span class="s2">      a single Python tuple, which single tuple object replaces all of the</span>
<span class="s2">      stack from the topmost markobject onward.  For example,</span>

<span class="s2">      Stack before: ... markobject 1 2 3 &#39;abc&#39;</span>
<span class="s2">      Stack after:  ... (1, 2, 3, &#39;abc&#39;)</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TUPLE1&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x85</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a one-tuple out of the topmost item on the stack.</span>

<span class="s2">      This code pops one value off the stack and pushes a tuple of</span>
<span class="s2">      length 1 whose one item is that value back onto it.  In other</span>
<span class="s2">      words:</span>

<span class="s2">          stack[-1] = tuple(stack[-1:])</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TUPLE2&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x86</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a two-tuple out of the top two items on the stack.</span>

<span class="s2">      This code pops two values off the stack and pushes a tuple of</span>
<span class="s2">      length 2 whose items are those values back onto it.  In other</span>
<span class="s2">      words:</span>

<span class="s2">          stack[-2:] = [tuple(stack[-2:])]</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TUPLE3&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x87</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pytuple</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a three-tuple out of the top three items on the stack.</span>

<span class="s2">      This code pops three values off the stack and pushes a tuple of</span>
<span class="s2">      length 3 whose items are those values back onto it.  In other</span>
<span class="s2">      words:</span>

<span class="s2">          stack[-3:] = [tuple(stack[-3:])]</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to build dicts.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EMPTY_DICT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;}&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Push an empty dict.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DICT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a dict out of the topmost stack slice, after markobject.</span>

<span class="s2">      All the stack entries following the topmost markobject are placed into</span>
<span class="s2">      a single Python dict, which single dict object replaces all of the</span>
<span class="s2">      stack from the topmost markobject onward.  The stack slice alternates</span>
<span class="s2">      key, value, key, value, ....  For example,</span>

<span class="s2">      Stack before: ... markobject 1 2 3 &#39;abc&#39;</span>
<span class="s2">      Stack after:  ... {1: 2, 3: &#39;abc&#39;}</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;SETITEM&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Add a key+value pair to an existing dict.</span>

<span class="s2">      Stack before:  ... pydict key value</span>
<span class="s2">      Stack after:   ... pydict</span>

<span class="s2">      where pydict has been modified via pydict[key] = value.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;SETITEMS&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">,</span> <span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pydict</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Add an arbitrary number of key+value pairs to an existing dict.</span>

<span class="s2">      The slice of the stack following the topmost markobject is taken as</span>
<span class="s2">      an alternating sequence of keys and values, added to the dict</span>
<span class="s2">      immediately under the topmost markobject.  Everything at and after the</span>
<span class="s2">      topmost markobject is popped, leaving the mutated dict at the top</span>
<span class="s2">      of the stack.</span>

<span class="s2">      Stack before:  ... pydict markobject key_1 value_1 ... key_n value_n</span>
<span class="s2">      Stack after:   ... pydict</span>

<span class="s2">      where pydict has been modified via pydict[key_i] = value_i for i in</span>
<span class="s2">      1, 2, ..., n, and in that order.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Stack manipulation.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;POP&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Discard the top stack item, shrinking the stack by one item.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DUP&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Push the top stack item onto the stack again, duplicating it.&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;MARK&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;(&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push markobject onto the stack.</span>

<span class="s2">      markobject is a unique object, used by other opcodes to identify a</span>
<span class="s2">      region of the stack containing a variable number of objects for them</span>
<span class="s2">      to work on.  See markobject.doc for more detail.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;POP_MARK&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Pop all the stack objects at and above the topmost markobject.</span>

<span class="s2">      When an opcode using a variable number of stack objects is done,</span>
<span class="s2">      POP_MARK is used to remove those objects, and to remove the markobject</span>
<span class="s2">      that delimited their starting position on the stack.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Memo manipulation.  There are really only two operations (get and put),</span>
    <span class="c1"># each in all-text, &quot;short binary&quot;, and &quot;long binary&quot; flavors.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_short</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Read an object from the memo and push it on the stack.</span>

<span class="s2">      The index of the memo object to push is given by the newline-terminated</span>
<span class="s2">      decimal string following.  BINGET and LONG_BINGET are space-optimized</span>
<span class="s2">      versions.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINGET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Read an object from the memo and push it on the stack.</span>

<span class="s2">      The index of the memo object to push is given by the 1-byte unsigned</span>
<span class="s2">      integer following.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;LONG_BINGET&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;j&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">int4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Read an object from the memo and push it on the stack.</span>

<span class="s2">      The index of the memo object to push is given by the 4-byte signed</span>
<span class="s2">      little-endian integer following.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;p&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_short</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s2">      The index of the memo location to write into is given by the newline-</span>
<span class="s2">      terminated decimal string following.  BINPUT and LONG_BINPUT are</span>
<span class="s2">      space-optimized versions.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINPUT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s2">      The index of the memo location to write into is given by the 1-byte</span>
<span class="s2">      unsigned integer following.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;LONG_BINPUT&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">int4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store the stack top into the memo.  The stack is not popped.</span>

<span class="s2">      The index of the memo location to write into is given by the 4-byte</span>
<span class="s2">      signed little-endian integer following.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Access the extension registry (predefined objects).  Akin to the GET</span>
    <span class="c1"># family.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EXT1&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x82</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Extension code.</span>

<span class="s2">      This code and the similar EXT2 and EXT4 allow using a registry</span>
<span class="s2">      of popular objects that are pickled by name, typically classes.</span>
<span class="s2">      It is envisioned that through a global negotiation and</span>
<span class="s2">      registration process, third parties can set up a mapping between</span>
<span class="s2">      ints and object names.</span>

<span class="s2">      In order to guarantee pickle interchangeability, the extension</span>
<span class="s2">      code registry ought to be global, although a range of codes may</span>
<span class="s2">      be reserved for private use.</span>

<span class="s2">      EXT1 has a 1-byte integer argument.  This is used to index into the</span>
<span class="s2">      extension registry, and the object at that index is pushed on the stack.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EXT2&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x83</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint2</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Extension code.</span>

<span class="s2">      See EXT1.  EXT2 has a two-byte integer argument.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EXT4&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x84</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">int4</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Extension code.</span>

<span class="s2">      See EXT1.  EXT4 has a four-byte integer argument.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Push a class object, or module function, on the stack, via its module</span>
    <span class="c1"># and name.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;GLOBAL&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl_noescape_pair</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push a global object (module.attr) on the stack.</span>

<span class="s2">      Two newline-terminated strings follow the GLOBAL opcode.  The first is</span>
<span class="s2">      taken as a module name, and the second as a class name.  The class</span>
<span class="s2">      object module.class is pushed on the stack.  More accurately, the</span>
<span class="s2">      object returned by self.find_class(module, class) is pushed on the</span>
<span class="s2">      stack, so unpickling subclasses can override this form of lookup.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to build objects of classes pickle doesn&#39;t know about directly</span>
    <span class="c1"># (user-defined classes).  I despair of documenting this accurately</span>
    <span class="c1"># and comprehensibly -- you really have to read the pickle code to</span>
    <span class="c1"># find all the special cases.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;REDUCE&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push an object built from a callable and an argument tuple.</span>

<span class="s2">      The opcode is named to remind of the __reduce__() method.</span>

<span class="s2">      Stack before: ... callable pytuple</span>
<span class="s2">      Stack after:  ... callable(*pytuple)</span>

<span class="s2">      The callable and the argument tuple are the first two items returned</span>
<span class="s2">      by a __reduce__ method.  Applying the callable to the argtuple is</span>
<span class="s2">      supposed to reproduce the original object, or at least get it started.</span>
<span class="s2">      If the __reduce__ method returns a 3-tuple, the last component is an</span>
<span class="s2">      argument to be passed to the object&#39;s __setstate__, and then the REDUCE</span>
<span class="s2">      opcode is followed by code to create setstate&#39;s argument, and then a</span>
<span class="s2">      BUILD opcode to apply  __setstate__ to that argument.</span>

<span class="s2">      If type(callable) is not ClassType, REDUCE complains unless the</span>
<span class="s2">      callable has been registered with the copy_reg module&#39;s</span>
<span class="s2">      safe_constructors dict, or the callable has a magic</span>
<span class="s2">      &#39;__safe_for_unpickling__&#39; attribute with a true value.  I&#39;m not sure</span>
<span class="s2">      why it does this, but I&#39;ve sure seen this complaint often enough when</span>
<span class="s2">      I didn&#39;t want to &lt;wink&gt;.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BUILD&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Finish building an object, via __setstate__ or dict update.</span>

<span class="s2">      Stack before: ... anyobject argument</span>
<span class="s2">      Stack after:  ... anyobject</span>

<span class="s2">      where anyobject may have been mutated, as follows:</span>

<span class="s2">      If the object has a __setstate__ method,</span>

<span class="s2">          anyobject.__setstate__(argument)</span>

<span class="s2">      is called.</span>

<span class="s2">      Else the argument must be a dict, the object must have a __dict__, and</span>
<span class="s2">      the object is updated via</span>

<span class="s2">          anyobject.__dict__.update(argument)</span>

<span class="s2">      This may raise RuntimeError in restricted execution mode (which</span>
<span class="s2">      disallows access to __dict__ directly); in that case, the object</span>
<span class="s2">      is updated instead via</span>

<span class="s2">          for k, v in argument.items():</span>
<span class="s2">              anyobject[k] = v</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;INST&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl_noescape_pair</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a class instance.</span>

<span class="s2">      This is the protocol 0 version of protocol 1&#39;s OBJ opcode.</span>
<span class="s2">      INST is followed by two newline-terminated strings, giving a</span>
<span class="s2">      module and class name, just as for the GLOBAL opcode (and see</span>
<span class="s2">      GLOBAL for more details about that).  self.find_class(module, name)</span>
<span class="s2">      is used to get a class object.</span>

<span class="s2">      In addition, all the objects on the stack following the topmost</span>
<span class="s2">      markobject are gathered into a tuple and popped (along with the</span>
<span class="s2">      topmost markobject), just as for the TUPLE opcode.</span>

<span class="s2">      Now it gets complicated.  If all of these are true:</span>

<span class="s2">        + The argtuple is empty (markobject was at the top of the stack</span>
<span class="s2">          at the start).</span>

<span class="s2">        + It&#39;s an old-style class object (the type of the class object is</span>
<span class="s2">          ClassType).</span>

<span class="s2">        + The class object does not have a __getinitargs__ attribute.</span>

<span class="s2">      then we want to create an old-style class instance without invoking</span>
<span class="s2">      its __init__() method (pickle has waffled on this over the years; not</span>
<span class="s2">      calling __init__() is current wisdom).  In this case, an instance of</span>
<span class="s2">      an old-style dummy class is created, and then we try to rebind its</span>
<span class="s2">      __class__ attribute to the desired class object.  If this succeeds,</span>
<span class="s2">      the new instance object is pushed on the stack, and we&#39;re done.  In</span>
<span class="s2">      restricted execution mode it can fail (assignment to __class__ is</span>
<span class="s2">      disallowed), and I&#39;m not really sure what happens then -- it looks</span>
<span class="s2">      like the code ends up calling the class object&#39;s __init__ anyway,</span>
<span class="s2">      via falling into the next case.</span>

<span class="s2">      Else (the argtuple is not empty, it&#39;s not an old-style class object,</span>
<span class="s2">      or the class object does have a __getinitargs__ attribute), the code</span>
<span class="s2">      first insists that the class object have a __safe_for_unpickling__</span>
<span class="s2">      attribute.  Unlike as for the __safe_for_unpickling__ check in REDUCE,</span>
<span class="s2">      it doesn&#39;t matter whether this attribute has a true or false value, it</span>
<span class="s2">      only matters whether it exists (XXX this is a bug; cPickle</span>
<span class="s2">      requires the attribute to be true).  If __safe_for_unpickling__</span>
<span class="s2">      doesn&#39;t exist, UnpicklingError is raised.</span>

<span class="s2">      Else (the class object does have a __safe_for_unpickling__ attr),</span>
<span class="s2">      the class object obtained from INST&#39;s arguments is applied to the</span>
<span class="s2">      argtuple obtained from the stack, and the resulting instance object</span>
<span class="s2">      is pushed on the stack.</span>

<span class="s2">      NOTE:  checks for __safe_for_unpickling__ went away in Python 2.3.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;OBJ&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">markobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">,</span> <span class="n">stackslice</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build a class instance.</span>

<span class="s2">      This is the protocol 1 version of protocol 0&#39;s INST opcode, and is</span>
<span class="s2">      very much like it.  The major difference is that the class object</span>
<span class="s2">      is taken off the stack, allowing it to be retrieved from the memo</span>
<span class="s2">      repeatedly if several instances of the same class are created.  This</span>
<span class="s2">      can be much more efficient (in both time and space) than repeatedly</span>
<span class="s2">      embedding the module and class names in INST opcodes.</span>

<span class="s2">      Unlike INST, OBJ takes no arguments from the opcode stream.  Instead</span>
<span class="s2">      the class object is taken off the stack, immediately above the</span>
<span class="s2">      topmost markobject:</span>

<span class="s2">      Stack before: ... markobject classobject stackslice</span>
<span class="s2">      Stack after:  ... new_instance_object</span>

<span class="s2">      As for INST, the remainder of the stack above the markobject is</span>
<span class="s2">      gathered into an argument tuple, and then the logic seems identical,</span>
<span class="s2">      except that no __safe_for_unpickling__ check is done (XXX this is</span>
<span class="s2">      a bug; cPickle does test __safe_for_unpickling__).  See INST for</span>
<span class="s2">      the gory details.</span>

<span class="s2">      NOTE:  In Python 2.3, INST and OBJ are identical except for how they</span>
<span class="s2">      get the class object.  That was always the intent; the implementations</span>
<span class="s2">      had diverged for accidental reasons.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;NEWOBJ&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x81</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">,</span> <span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Build an object instance.</span>

<span class="s2">      The stack before should be thought of as containing a class</span>
<span class="s2">      object followed by an argument tuple (the tuple being the stack</span>
<span class="s2">      top).  Call these cls and args.  They are popped off the stack,</span>
<span class="s2">      and the value returned by cls.__new__(cls, *args) is pushed back</span>
<span class="s2">      onto the stack.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Machine control.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;PROTO&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x80</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">uint1</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Protocol version indicator.</span>

<span class="s2">      For protocol 2 and above, a pickle must start with this opcode.</span>
<span class="s2">      The argument is the protocol version, an int in range(2, 256).</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;STOP&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Stop the unpickling machine.</span>

<span class="s2">      Every pickle ends with this opcode.  The object at the top of the stack</span>
<span class="s2">      is popped, and that&#39;s the result of unpickling.  The stack should be</span>
<span class="s2">      empty then.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="c1"># Ways to deal with persistent IDs.</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;PERSID&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="n">stringnl_noescape</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push an object identified by a persistent ID.</span>

<span class="s2">      The pickle module doesn&#39;t define what a persistent ID means.  PERSID&#39;s</span>
<span class="s2">      argument is a newline-terminated str-style (no embedded escapes, no</span>
<span class="s2">      bracketing quote characters) string, which *is* &quot;the persistent ID&quot;.</span>
<span class="s2">      The unpickler passes this string to self.persistent_load().  Whatever</span>
<span class="s2">      object that returns is pushed on the stack.  There is no implementation</span>
<span class="s2">      of persistent_load() in Python&#39;s unpickler:  it must be supplied by an</span>
<span class="s2">      unpickler subclass.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>

    <span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINPERSID&#39;</span><span class="p">,</span>
      <span class="n">code</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span>
      <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
      <span class="n">stack_before</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">anyobject</span><span class="p">],</span>
      <span class="n">proto</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Push an object identified by a persistent ID.</span>

<span class="s2">      Like PERSID, except the persistent ID is popped off the stack (instead</span>
<span class="s2">      of being a string embedded in the opcode bytestream).  The persistent</span>
<span class="s2">      ID is passed to self.persistent_load(), and whatever object that</span>
<span class="s2">      returns is pushed on the stack.  See PERSID for more detail.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">),</span>
<span class="p">]</span>
<span class="k">del</span> <span class="n">I</span>

<span class="c1"># Verify uniqueness of .name and .code members.</span>
<span class="n">name2i</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">code2i</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opcodes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">name2i</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;repeated name </span><span class="si">%r</span><span class="s2"> at indices </span><span class="si">%d</span><span class="s2"> and </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">code</span> <span class="ow">in</span> <span class="n">code2i</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;repeated code </span><span class="si">%r</span><span class="s2"> at indices </span><span class="si">%d</span><span class="s2"> and </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">code2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">name2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">code2i</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="k">del</span> <span class="n">name2i</span><span class="p">,</span> <span class="n">code2i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span>

<span class="c1">##############################################################################</span>
<span class="c1"># Build a code2op dict, mapping opcode characters to OpcodeInfo records.</span>
<span class="c1"># Also ensure we&#39;ve got the same stuff as pickle.py, although the</span>
<span class="c1"># introspection here is dicey.</span>

<span class="n">code2op</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>
    <span class="n">code2op</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
<span class="k">del</span> <span class="n">d</span>

<span class="k">def</span> <span class="nf">assure_pickle_consistency</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">re</span>

    <span class="n">copy</span> <span class="o">=</span> <span class="n">code2op</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pickle</span><span class="o">.</span><span class="n">__all__</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;[A-Z][A-Z0-9_]+$&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;skipping </span><span class="si">%r</span><span class="s2">: it doesn&#39;t look like an opcode name&quot;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="k">continue</span>
        <span class="n">picklecode</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">picklecode</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">picklecode</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s2">&quot;skipping </span><span class="si">%r</span><span class="s2">: value </span><span class="si">%r</span><span class="s2"> doesn&#39;t look like a pickle &quot;</span>
                       <span class="s2">&quot;code&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">picklecode</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">picklecode</span> <span class="ow">in</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;checking name </span><span class="si">%r</span><span class="s2"> w/ code </span><span class="si">%r</span><span class="s2"> for consistency&quot;</span> <span class="o">%</span> <span class="p">(</span>
                      <span class="n">name</span><span class="p">,</span> <span class="n">picklecode</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">copy</span><span class="p">[</span><span class="n">picklecode</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;for pickle code </span><span class="si">%r</span><span class="s2">, pickle.py uses name </span><span class="si">%r</span><span class="s2"> &quot;</span>
                                 <span class="s2">&quot;but we&#39;re using name </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">picklecode</span><span class="p">,</span>
                                                              <span class="n">name</span><span class="p">,</span>
                                                              <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="c1"># Forget this one.  Any left over in copy at the end are a problem</span>
            <span class="c1"># of a different kind.</span>
            <span class="k">del</span> <span class="n">copy</span><span class="p">[</span><span class="n">picklecode</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pickle.py appears to have a pickle opcode with &quot;</span>
                             <span class="s2">&quot;name </span><span class="si">%r</span><span class="s2"> and code </span><span class="si">%r</span><span class="s2">, but we don&#39;t&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">picklecode</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;we appear to have pickle opcodes that pickle.py doesn&#39;t have:&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">copy</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    name </span><span class="si">%r</span><span class="s2"> with code </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

<span class="n">assure_pickle_consistency</span><span class="p">()</span>
<span class="k">del</span> <span class="n">assure_pickle_consistency</span>

<span class="c1">##############################################################################</span>
<span class="c1"># A pickle opcode generator.</span>

<div class="viewcode-block" id="genops"><a class="viewcode-back" href="../generated/pickletools.genops.html#pickletools.genops">[docs]</a><span class="k">def</span> <span class="nf">genops</span><span class="p">(</span><span class="n">pickle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate all the opcodes in a pickle.</span>

<span class="sd">    &#39;pickle&#39; is a file-like object, or string, containing the pickle.</span>

<span class="sd">    Each opcode in the pickle is generated, from the current pickle position,</span>
<span class="sd">    stopping after a STOP opcode is delivered.  A triple is generated for</span>
<span class="sd">    each opcode:</span>

<span class="sd">        opcode, arg, pos</span>

<span class="sd">    opcode is an OpcodeInfo record, describing the current opcode.</span>

<span class="sd">    If the opcode has an argument embedded in the pickle, arg is its decoded</span>
<span class="sd">    value, as a Python object.  If the opcode doesn&#39;t have an argument, arg</span>
<span class="sd">    is None.</span>

<span class="sd">    If the pickle has a tell() method, pos was the value of pickle.tell()</span>
<span class="sd">    before reading the current opcode.  If the pickle is a string object,</span>
<span class="sd">    it&#39;s wrapped in a StringIO object, and the latter&#39;s tell() result is</span>
<span class="sd">    used.  Else (the pickle doesn&#39;t have a tell(), and it&#39;s not obvious how</span>
<span class="sd">    to query its current position) pos is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">cStringIO</span> <span class="kn">as</span> <span class="nn">StringIO</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">pickle</span> <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span> <span class="s2">&quot;tell&quot;</span><span class="p">):</span>
        <span class="n">getpos</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">tell</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">getpos</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">getpos</span><span class="p">()</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">opcode</span> <span class="o">=</span> <span class="n">code2op</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pickle exhausted before seeing STOP&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at position </span><span class="si">%s</span><span class="s2">, opcode </span><span class="si">%r</span><span class="s2"> unknown&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                 <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="s2">&quot;&lt;unknown&gt;&quot;</span> <span class="ow">or</span> <span class="n">pos</span><span class="p">,</span>
                                 <span class="n">code</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">opcode</span><span class="o">.</span><span class="n">arg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;STOP&#39;</span>
            <span class="k">break</span></div>

<span class="c1">##############################################################################</span>
<span class="c1"># A pickle optimizer.</span>

<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../generated/pickletools.optimize.html#pickletools.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="s1">&#39;Optimize a pickle string by removing unused PUT opcodes&#39;</span>
    <span class="n">gets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>            <span class="c1"># set of args used by a GET opcode</span>
    <span class="n">puts</span> <span class="o">=</span> <span class="p">[]</span>               <span class="c1"># (arg, startpos, stoppos) for the PUT opcodes</span>
    <span class="n">prevpos</span> <span class="o">=</span> <span class="bp">None</span>          <span class="c1"># set to pos if previous opcode was a PUT</span>
    <span class="k">for</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">genops</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prevpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">puts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">prevarg</span><span class="p">,</span> <span class="n">prevpos</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
            <span class="n">prevpos</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="s1">&#39;PUT&#39;</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">prevarg</span><span class="p">,</span> <span class="n">prevpos</span> <span class="o">=</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="s1">&#39;GET&#39;</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">gets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="c1"># Copy the pickle string except for PUTS without a corresponding GET</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">puts</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">stop</span> <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="n">gets</span><span class="p">)</span> <span class="k">else</span> <span class="n">start</span>
        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">stop</span>
    <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<span class="c1">##############################################################################</span>
<span class="c1"># A symbolic pickle disassembler.</span>

<div class="viewcode-block" id="dis"><a class="viewcode-back" href="../generated/pickletools.dis.html#pickletools.dis">[docs]</a><span class="k">def</span> <span class="nf">dis</span><span class="p">(</span><span class="n">pickle</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">indentlevel</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a symbolic disassembly of a pickle.</span>

<span class="sd">    &#39;pickle&#39; is a file-like object, or string, containing a (at least one)</span>
<span class="sd">    pickle.  The pickle is disassembled from the current position, through</span>
<span class="sd">    the first STOP opcode encountered.</span>

<span class="sd">    Optional arg &#39;out&#39; is a file-like object to which the disassembly is</span>
<span class="sd">    printed.  It defaults to sys.stdout.</span>

<span class="sd">    Optional arg &#39;memo&#39; is a Python dict, used as the pickle&#39;s memo.  It</span>
<span class="sd">    may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.</span>
<span class="sd">    Passing the same memo object to another dis() call then allows disassembly</span>
<span class="sd">    to proceed across multiple pickles that were all created by the same</span>
<span class="sd">    pickler with the same memo.  Ordinarily you don&#39;t need to worry about this.</span>

<span class="sd">    Optional arg indentlevel is the number of blanks by which to indent</span>
<span class="sd">    a new MARK level.  It defaults to 4.</span>

<span class="sd">    In addition to printing the disassembly, some sanity checks are made:</span>

<span class="sd">    + All embedded opcode arguments &quot;make sense&quot;.</span>

<span class="sd">    + Explicit and implicit pop operations have enough items on the stack.</span>

<span class="sd">    + When an opcode implicitly refers to a markobject, a markobject is</span>
<span class="sd">      actually on the stack.</span>

<span class="sd">    + A memo entry isn&#39;t referenced before it&#39;s defined.</span>

<span class="sd">    + The markobject isn&#39;t stored in the memo.</span>

<span class="sd">    + A memo entry isn&#39;t redefined.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Most of the hair here is for sanity checks, but most of it is needed</span>
    <span class="c1"># anyway to detect when a protocol 0 POP takes a MARK off the stack</span>
    <span class="c1"># (which in turn is needed to indent MARK blocks correctly).</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># crude emulation of unpickler stack</span>
    <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>       <span class="c1"># crude emulation of unpickler memo</span>
    <span class="n">maxproto</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>       <span class="c1"># max protocol number seen</span>
    <span class="n">markstack</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># bytecode positions of MARK opcodes</span>
    <span class="n">indentchunk</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">indentlevel</span>
    <span class="n">errormsg</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">genops</span><span class="p">(</span><span class="n">pickle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">out</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%5d</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">pos</span><span class="p">,</span>

        <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%-4s</span><span class="s2"> </span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">opcode</span><span class="o">.</span><span class="n">code</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                              <span class="n">indentchunk</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">markstack</span><span class="p">),</span>
                              <span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">maxproto</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxproto</span><span class="p">,</span> <span class="n">opcode</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span>
        <span class="n">before</span> <span class="o">=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">stack_before</span>    <span class="c1"># don&#39;t mutate</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">stack_after</span>      <span class="c1"># don&#39;t mutate</span>
        <span class="n">numtopop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>

        <span class="c1"># See whether a MARK should be popped.</span>
        <span class="n">markmsg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">markobject</span> <span class="ow">in</span> <span class="n">before</span> <span class="ow">or</span> <span class="p">(</span><span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;POP&quot;</span> <span class="ow">and</span>
                                    <span class="n">stack</span> <span class="ow">and</span>
                                    <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">markobject</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">markobject</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">after</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">markobject</span> <span class="ow">in</span> <span class="n">before</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">before</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">stackslice</span>
            <span class="k">if</span> <span class="n">markstack</span><span class="p">:</span>
                <span class="n">markpos</span> <span class="o">=</span> <span class="n">markstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">markpos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">markmsg</span> <span class="o">=</span> <span class="s2">&quot;(MARK at unknown opcode offset)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">markmsg</span> <span class="o">=</span> <span class="s2">&quot;(MARK at </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">markpos</span>
                <span class="c1"># Pop everything at and after the topmost markobject.</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">markobject</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="c1"># Stop later code from popping too much.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">numtopop</span> <span class="o">=</span> <span class="n">before</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">markobject</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;POP&quot;</span>
                    <span class="n">numtopop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="n">markmsg</span> <span class="o">=</span> <span class="s2">&quot;no MARK exists on stack&quot;</span>

        <span class="c1"># Check for correct memo usage.</span>
        <span class="k">if</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;PUT&quot;</span><span class="p">,</span> <span class="s2">&quot;BINPUT&quot;</span><span class="p">,</span> <span class="s2">&quot;LONG_BINPUT&quot;</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s2">&quot;memo key </span><span class="si">%r</span><span class="s2"> already defined&quot;</span> <span class="o">%</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s2">&quot;stack is empty -- can&#39;t store into memo&quot;</span>
            <span class="k">elif</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">markobject</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s2">&quot;can&#39;t store markobject in the memo&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">opcode</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="s2">&quot;BINGET&quot;</span><span class="p">,</span> <span class="s2">&quot;LONG_BINGET&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">after</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">after</span> <span class="o">=</span> <span class="p">[</span><span class="n">memo</span><span class="p">[</span><span class="n">arg</span><span class="p">]]</span>     <span class="c1"># for better stack emulation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errormsg</span> <span class="o">=</span> <span class="s2">&quot;memo key </span><span class="si">%r</span><span class="s2"> has never been stored into&quot;</span> <span class="o">%</span> <span class="n">arg</span>

        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">markmsg</span><span class="p">:</span>
            <span class="c1"># make a mild effort to align arguments</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">markmsg</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">markmsg</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">out</span><span class="p">,</span> <span class="n">line</span>

        <span class="k">if</span> <span class="n">errormsg</span><span class="p">:</span>
            <span class="c1"># Note that we delayed complaining until the offending opcode</span>
            <span class="c1"># was printed.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errormsg</span><span class="p">)</span>

        <span class="c1"># Emulate the stack effects.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">numtopop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tries to pop </span><span class="si">%d</span><span class="s2"> items from stack with &quot;</span>
                             <span class="s2">&quot;only </span><span class="si">%d</span><span class="s2"> items&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">numtopop</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">numtopop</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="n">numtopop</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">markobject</span> <span class="ow">in</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">markobject</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">before</span>
            <span class="n">markstack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

    <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">out</span><span class="p">,</span> <span class="s2">&quot;highest protocol among opcodes =&quot;</span><span class="p">,</span> <span class="n">maxproto</span>
    <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stack not empty after STOP: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">stack</span><span class="p">)</span></div>

<span class="c1"># For use in the doctest, simply as an example of a class to pickle.</span>
<span class="k">class</span> <span class="nc">_Example</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">_dis_test</span> <span class="o">=</span> <span class="s2">r&quot;&quot;&quot;</span>
<span class="s2">&gt;&gt;&gt; import pickle</span>
<span class="s2">&gt;&gt;&gt; x = [1, 2, (3, 4), {&#39;abc&#39;: u&quot;def&quot;}]</span>
<span class="s2">&gt;&gt;&gt; pkl = pickle.dumps(x, 0)</span>
<span class="s2">&gt;&gt;&gt; dis(pkl)</span>
<span class="s2">    0: (    MARK</span>
<span class="s2">    1: l        LIST       (MARK at 0)</span>
<span class="s2">    2: p    PUT        0</span>
<span class="s2">    5: I    INT        1</span>
<span class="s2">    8: a    APPEND</span>
<span class="s2">    9: I    INT        2</span>
<span class="s2">   12: a    APPEND</span>
<span class="s2">   13: (    MARK</span>
<span class="s2">   14: I        INT        3</span>
<span class="s2">   17: I        INT        4</span>
<span class="s2">   20: t        TUPLE      (MARK at 13)</span>
<span class="s2">   21: p    PUT        1</span>
<span class="s2">   24: a    APPEND</span>
<span class="s2">   25: (    MARK</span>
<span class="s2">   26: d        DICT       (MARK at 25)</span>
<span class="s2">   27: p    PUT        2</span>
<span class="s2">   30: S    STRING     &#39;abc&#39;</span>
<span class="s2">   37: p    PUT        3</span>
<span class="s2">   40: V    UNICODE    u&#39;def&#39;</span>
<span class="s2">   45: p    PUT        4</span>
<span class="s2">   48: s    SETITEM</span>
<span class="s2">   49: a    APPEND</span>
<span class="s2">   50: .    STOP</span>
<span class="s2">highest protocol among opcodes = 0</span>

<span class="s2">Try again with a &quot;binary&quot; pickle.</span>

<span class="s2">&gt;&gt;&gt; pkl = pickle.dumps(x, 1)</span>
<span class="s2">&gt;&gt;&gt; dis(pkl)</span>
<span class="s2">    0: ]    EMPTY_LIST</span>
<span class="s2">    1: q    BINPUT     0</span>
<span class="s2">    3: (    MARK</span>
<span class="s2">    4: K        BININT1    1</span>
<span class="s2">    6: K        BININT1    2</span>
<span class="s2">    8: (        MARK</span>
<span class="s2">    9: K            BININT1    3</span>
<span class="s2">   11: K            BININT1    4</span>
<span class="s2">   13: t            TUPLE      (MARK at 8)</span>
<span class="s2">   14: q        BINPUT     1</span>
<span class="s2">   16: }        EMPTY_DICT</span>
<span class="s2">   17: q        BINPUT     2</span>
<span class="s2">   19: U        SHORT_BINSTRING &#39;abc&#39;</span>
<span class="s2">   24: q        BINPUT     3</span>
<span class="s2">   26: X        BINUNICODE u&#39;def&#39;</span>
<span class="s2">   34: q        BINPUT     4</span>
<span class="s2">   36: s        SETITEM</span>
<span class="s2">   37: e        APPENDS    (MARK at 3)</span>
<span class="s2">   38: .    STOP</span>
<span class="s2">highest protocol among opcodes = 1</span>

<span class="s2">Exercise the INST/OBJ/BUILD family.</span>

<span class="s2">&gt;&gt;&gt; import pickletools</span>
<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(pickletools.dis, 0))</span>
<span class="s2">    0: c    GLOBAL     &#39;pickletools dis&#39;</span>
<span class="s2">   17: p    PUT        0</span>
<span class="s2">   20: .    STOP</span>
<span class="s2">highest protocol among opcodes = 0</span>

<span class="s2">&gt;&gt;&gt; from pickletools import _Example</span>
<span class="s2">&gt;&gt;&gt; x = [_Example(42)] * 2</span>
<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(x, 0))</span>
<span class="s2">    0: (    MARK</span>
<span class="s2">    1: l        LIST       (MARK at 0)</span>
<span class="s2">    2: p    PUT        0</span>
<span class="s2">    5: (    MARK</span>
<span class="s2">    6: i        INST       &#39;pickletools _Example&#39; (MARK at 5)</span>
<span class="s2">   28: p    PUT        1</span>
<span class="s2">   31: (    MARK</span>
<span class="s2">   32: d        DICT       (MARK at 31)</span>
<span class="s2">   33: p    PUT        2</span>
<span class="s2">   36: S    STRING     &#39;value&#39;</span>
<span class="s2">   45: p    PUT        3</span>
<span class="s2">   48: I    INT        42</span>
<span class="s2">   52: s    SETITEM</span>
<span class="s2">   53: b    BUILD</span>
<span class="s2">   54: a    APPEND</span>
<span class="s2">   55: g    GET        1</span>
<span class="s2">   58: a    APPEND</span>
<span class="s2">   59: .    STOP</span>
<span class="s2">highest protocol among opcodes = 0</span>

<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(x, 1))</span>
<span class="s2">    0: ]    EMPTY_LIST</span>
<span class="s2">    1: q    BINPUT     0</span>
<span class="s2">    3: (    MARK</span>
<span class="s2">    4: (        MARK</span>
<span class="s2">    5: c            GLOBAL     &#39;pickletools _Example&#39;</span>
<span class="s2">   27: q            BINPUT     1</span>
<span class="s2">   29: o            OBJ        (MARK at 4)</span>
<span class="s2">   30: q        BINPUT     2</span>
<span class="s2">   32: }        EMPTY_DICT</span>
<span class="s2">   33: q        BINPUT     3</span>
<span class="s2">   35: U        SHORT_BINSTRING &#39;value&#39;</span>
<span class="s2">   42: q        BINPUT     4</span>
<span class="s2">   44: K        BININT1    42</span>
<span class="s2">   46: s        SETITEM</span>
<span class="s2">   47: b        BUILD</span>
<span class="s2">   48: h        BINGET     2</span>
<span class="s2">   50: e        APPENDS    (MARK at 3)</span>
<span class="s2">   51: .    STOP</span>
<span class="s2">highest protocol among opcodes = 1</span>

<span class="s2">Try &quot;the canonical&quot; recursive-object test.</span>

<span class="s2">&gt;&gt;&gt; L = []</span>
<span class="s2">&gt;&gt;&gt; T = L,</span>
<span class="s2">&gt;&gt;&gt; L.append(T)</span>
<span class="s2">&gt;&gt;&gt; L[0] is T</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; T[0] is L</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; L[0][0] is L</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; T[0][0] is T</span>
<span class="s2">True</span>
<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(L, 0))</span>
<span class="s2">    0: (    MARK</span>
<span class="s2">    1: l        LIST       (MARK at 0)</span>
<span class="s2">    2: p    PUT        0</span>
<span class="s2">    5: (    MARK</span>
<span class="s2">    6: g        GET        0</span>
<span class="s2">    9: t        TUPLE      (MARK at 5)</span>
<span class="s2">   10: p    PUT        1</span>
<span class="s2">   13: a    APPEND</span>
<span class="s2">   14: .    STOP</span>
<span class="s2">highest protocol among opcodes = 0</span>

<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(L, 1))</span>
<span class="s2">    0: ]    EMPTY_LIST</span>
<span class="s2">    1: q    BINPUT     0</span>
<span class="s2">    3: (    MARK</span>
<span class="s2">    4: h        BINGET     0</span>
<span class="s2">    6: t        TUPLE      (MARK at 3)</span>
<span class="s2">    7: q    BINPUT     1</span>
<span class="s2">    9: a    APPEND</span>
<span class="s2">   10: .    STOP</span>
<span class="s2">highest protocol among opcodes = 1</span>

<span class="s2">Note that, in the protocol 0 pickle of the recursive tuple, the disassembler</span>
<span class="s2">has to emulate the stack in order to realize that the POP opcode at 16 gets</span>
<span class="s2">rid of the MARK at 0.</span>

<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(T, 0))</span>
<span class="s2">    0: (    MARK</span>
<span class="s2">    1: (        MARK</span>
<span class="s2">    2: l            LIST       (MARK at 1)</span>
<span class="s2">    3: p        PUT        0</span>
<span class="s2">    6: (        MARK</span>
<span class="s2">    7: g            GET        0</span>
<span class="s2">   10: t            TUPLE      (MARK at 6)</span>
<span class="s2">   11: p        PUT        1</span>
<span class="s2">   14: a        APPEND</span>
<span class="s2">   15: 0        POP</span>
<span class="s2">   16: 0        POP        (MARK at 0)</span>
<span class="s2">   17: g    GET        1</span>
<span class="s2">   20: .    STOP</span>
<span class="s2">highest protocol among opcodes = 0</span>

<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(T, 1))</span>
<span class="s2">    0: (    MARK</span>
<span class="s2">    1: ]        EMPTY_LIST</span>
<span class="s2">    2: q        BINPUT     0</span>
<span class="s2">    4: (        MARK</span>
<span class="s2">    5: h            BINGET     0</span>
<span class="s2">    7: t            TUPLE      (MARK at 4)</span>
<span class="s2">    8: q        BINPUT     1</span>
<span class="s2">   10: a        APPEND</span>
<span class="s2">   11: 1        POP_MARK   (MARK at 0)</span>
<span class="s2">   12: h    BINGET     1</span>
<span class="s2">   14: .    STOP</span>
<span class="s2">highest protocol among opcodes = 1</span>

<span class="s2">Try protocol 2.</span>

<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(L, 2))</span>
<span class="s2">    0: \x80 PROTO      2</span>
<span class="s2">    2: ]    EMPTY_LIST</span>
<span class="s2">    3: q    BINPUT     0</span>
<span class="s2">    5: h    BINGET     0</span>
<span class="s2">    7: \x85 TUPLE1</span>
<span class="s2">    8: q    BINPUT     1</span>
<span class="s2">   10: a    APPEND</span>
<span class="s2">   11: .    STOP</span>
<span class="s2">highest protocol among opcodes = 2</span>

<span class="s2">&gt;&gt;&gt; dis(pickle.dumps(T, 2))</span>
<span class="s2">    0: \x80 PROTO      2</span>
<span class="s2">    2: ]    EMPTY_LIST</span>
<span class="s2">    3: q    BINPUT     0</span>
<span class="s2">    5: h    BINGET     0</span>
<span class="s2">    7: \x85 TUPLE1</span>
<span class="s2">    8: q    BINPUT     1</span>
<span class="s2">   10: a    APPEND</span>
<span class="s2">   11: 0    POP</span>
<span class="s2">   12: h    BINGET     1</span>
<span class="s2">   14: .    STOP</span>
<span class="s2">highest protocol among opcodes = 2</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_memo_test</span> <span class="o">=</span> <span class="s2">r&quot;&quot;&quot;</span>
<span class="s2">&gt;&gt;&gt; import pickle</span>
<span class="s2">&gt;&gt;&gt; from StringIO import StringIO</span>
<span class="s2">&gt;&gt;&gt; f = StringIO()</span>
<span class="s2">&gt;&gt;&gt; p = pickle.Pickler(f, 2)</span>
<span class="s2">&gt;&gt;&gt; x = [1, 2, 3]</span>
<span class="s2">&gt;&gt;&gt; p.dump(x)</span>
<span class="s2">&gt;&gt;&gt; p.dump(x)</span>
<span class="s2">&gt;&gt;&gt; f.seek(0)</span>
<span class="s2">&gt;&gt;&gt; memo = {}</span>
<span class="s2">&gt;&gt;&gt; dis(f, memo=memo)</span>
<span class="s2">    0: \x80 PROTO      2</span>
<span class="s2">    2: ]    EMPTY_LIST</span>
<span class="s2">    3: q    BINPUT     0</span>
<span class="s2">    5: (    MARK</span>
<span class="s2">    6: K        BININT1    1</span>
<span class="s2">    8: K        BININT1    2</span>
<span class="s2">   10: K        BININT1    3</span>
<span class="s2">   12: e        APPENDS    (MARK at 5)</span>
<span class="s2">   13: .    STOP</span>
<span class="s2">highest protocol among opcodes = 2</span>
<span class="s2">&gt;&gt;&gt; dis(f, memo=memo)</span>
<span class="s2">   14: \x80 PROTO      2</span>
<span class="s2">   16: h    BINGET     0</span>
<span class="s2">   18: .    STOP</span>
<span class="s2">highest protocol among opcodes = 2</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">__test__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;disassembler_test&#39;</span><span class="p">:</span> <span class="n">_dis_test</span><span class="p">,</span>
            <span class="s1">&#39;disassembler_memo_test&#39;</span><span class="p">:</span> <span class="n">_memo_test</span><span class="p">,</span>
           <span class="p">}</span>

<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="k">return</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>